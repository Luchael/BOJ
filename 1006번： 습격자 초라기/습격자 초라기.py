#  **************************************************************************  #
#                                                                              #
#                                                       :::    :::    :::      #
#    Problem Number: 1006                              :+:    :+:      :+:     #
#                                                     +:+    +:+        +:+    #
#    By: luchael <boj.kr/u/luchael>                  +#+    +#+          +#+   #
#                                                   +#+      +#+        +#+    #
#    https://boj.kr/1006                           #+#        #+#      #+#     #
#    Solved: 2025/02/25 12:28:11 by luchael       ###          ###   ##.kr     #
#                                                                              #
#  **************************************************************************  #
I = 98765 # 그냥 대충 큰 수

def fillDP(dp):
    # dp 1번 줄은 각 경우마다 직접 값을 지정해놓기
    for i in range(1, l):
        v = 1 if enemy[0][i] + enemy[1][i] <= m else 2 # 안쪽과 바깥쪽 맞닿은 두 칸에 부대를 배치할 수 있는가?
        inside = 1 if enemy[0][i] + enemy[0][i-1] <= m else 2 # 안쪽 인접한 두 칸에 같은 부대를 배치할 수 있는가?
        outside = 1 if enemy[1][i] + enemy[1][i-1] <= m else 2 # 바깥쪽 인접한 두 칸에 같은 부대를 배치할 수 있는가?
        
        # dp[0]은 줄 별로 안쪽과 바깥쪽을 동시에 고려하면서 탐색한 값을 저장
        dp[0][i] = min(dp[0][i-1]+v, # 안쪽과 바깥쪽 맞닿은 곳에 같은 부대를 배치할 수 있을 때
                       dp[0][i-2] + inside + outside, # 바깥쪽 인접한 두 칸과 안쪽 인접한 두 칸에 같은 부대를 배치할 수 있을 때
                       dp[1][i-1] + inside + 1, # 안쪽 인접한 두 칸에 같은 부대를 배치하고, 바깥쪽 한 칸에 부대를 배치할 때
                       dp[2][i-1] + outside + 1)  # 바깥쪽 인접한 두 칸에 같은 부대를 배치하고, 안쪽 한 칸에 부대를 배치할 때
        # dp[1]은 바깥쪽 칸을 우선적으로 고려하면서 탐색한 값을 저장
        dp[1][i] = min(dp[2][i-1] + outside, dp[0][i-1] + 1) # 바깥쪽 인접한 두 칸에 같은 부대를 배치할 수 있을 때 / 바깥쪽 한 칸에만 부대를 배치할 때
        # dp[2]는 안쪽 칸을 우선적으로 고려하면서 탐색한 값을 저장
        dp[2][i] = min(dp[1][i-1] + inside, dp[0][i-1] + 1) # 안쪽 인접한 두 칸에 같은 부대를 배치할 수 있을 때 / 안쪽 한 칸에만 부대를 배치할 때
    return dp


T = int(input())

for _ in range(T):
    l, m = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    
    if l == 1: # 줄 수가 1줄이면, 이렇게 예외 처리 해줘야 함.
        print(1 if A[0] + B[0] <= m else 2)
        continue
    
    enemy = [A, B]
    k = l-1 # 배열의 마지막 인덱스 번호
    
    #1. [0]번줄과 [-1]번줄에 다른 부대를 배치한 경우
    dp = [[0]*l for _ in range(3)]
    dp[0][0] = 1 if enemy[0][0] + enemy[1][0] <= m else 2
    dp[1][0] = dp[2][0] = 1 # 여긴 당연히 하나밖에 고려할게 없으니 무조건 1
    ans = fillDP(dp)[0][k] # 연결된 게 없으니 끝날 때는 양쪽 다 고려한 상태로 끝나야 하므로 0번
    
    dp[0][0] = 2 # 여기서부터는 무조건 위랑 아래가 서로 다른 부대를 배치해야함.
    
    #2. [0]번줄 안쪽칸과 [-1]번줄 안쪽칸에 같은 부대를 배치한 경우
    if enemy[0][0] + enemy[0][-1] <= m:
        enemy[0][0] += I
        ans = min(ans, fillDP(dp)[1][k]) # 안쪽이 연결됐으니 끝날 때는 바깥쪽 우선 고려한 상태로 끝나야 하므로 1번
        enemy[0][0] -= I
    
    #3. [0]번줄 바깥쪽칸과 [-1]번줄 바깥쪽칸에 같은 부대를 배치한 경우
    if enemy[1][0] + enemy[1][-1] <= m:
        enemy[1][0] += I
        ans = min(ans, fillDP(dp)[2][k]) # 바깥 연결 => 안쪽 우선 => 2번
        enemy[1][0] -= I
    
    #4. [0]번줄, [-1]번줄 안쪽과 바깥쪽에 각각 같은 부대를 배치한 경우
    if enemy[0][0] + enemy[0][-1] <= m and enemy[1][0] + enemy[1][-1] <= m:
        enemy[0][0], enemy[1][0] = I,I
        ans = min(ans, fillDP(dp)[0][k-1]) # 양쪽 다 연결 => 동시 고려 => 0번 // 마지막 칸은 생각하면 안 되니까 k-1

    print(ans)